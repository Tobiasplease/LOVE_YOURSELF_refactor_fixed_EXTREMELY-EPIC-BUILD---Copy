# === IMPORTS ===
import cv2
import serial
import time
import os
import math
import random
import threading

# === MODULE IMPORTS ===
from mood.mood import update_feeling_brain, get_current_mood

# === ARDUINO SERIAL SETUP ===
serial_port = 'COM3'
baud_rate = 9600
ser = serial.Serial(serial_port, baud_rate, timeout=1)
time.sleep(2)

# === SERVO SETTINGS ===
servo_x = 90
servo_y = 90
target_x = 90
target_y = 90
servo_min = 45
servo_max = 135
easing_factor = 0.09
flip_x = False
flip_y = True

# === LUNG SETTINGS ===
lung_min = 10
lung_max = 40
lung_angle = 0.0
lung_pos = 90
breath_paused = False
pause_start_time = 0
last_breath_direction = None
pause_duration = 0.6
breath_speed = 4.0  # initial value

# === FACE DETECTION ===
confidence_threshold = 0.5
dead_zone = 20

# === IDLE GAZE SETTINGS ===
idle_amplitude_x = 30
idle_amplitude_y = 23
idle_center_x = 90
idle_center_y = 90
idle_target = (idle_center_x, idle_center_y)
idle_hold_until = 0

# === FACE-IDLE COOLDOWN SETTINGS ===
face_stable_timeout = 2.0
last_seen_time = time.time()

# === MOOD ===
last_mood_time = 0
mood_interval = 10

# === FACE DETECTOR ===
desktop = os.path.join(os.environ['USERPROFILE'], 'Desktop')
proto_path = os.path.join(desktop, "deploy.prototxt")
model_path = os.path.join(desktop, "res10_300x300_ssd_iter_140000.caffemodel")
net = cv2.dnn.readNetFromCaffe(proto_path, model_path)

# === CAMERA ===
cap = cv2.VideoCapture(0)

# === UTILS ===
def clamp(val, min_val, max_val):
    return max(min_val, min(max_val, val))

def detect_face_dnn(frame):
    h, w = frame.shape[:2]
    blob = cv2.dnn.blobFromImage(frame, 1.0, (300, 300), (104, 177, 123), False, False)
    net.setInput(blob)
    detections = net.forward()
    best_box = None
    best_conf = 0.0
    for i in range(detections.shape[2]):
        conf = detections[0, 0, i, 2]
        if conf > confidence_threshold and conf > best_conf:
            box = detections[0, 0, i, 3:7] * [w, h, w, h]
            best_box = box.astype("int")
            best_conf = conf
    return best_box

# === MAIN LOOP ===
last_time = time.time()
lung_eased = 90

while True:
    ret, frame = cap.read()
    if not ret:
        continue
    frame = cv2.resize(frame, (320, 240))
    frame = cv2.flip(frame, 1)
    now = time.time()
    delta = now - last_time
    last_time = now

    face_box = detect_face_dnn(frame)
    person_present = face_box is not None

    if person_present:
        last_seen_time = time.time()
        (startX, startY, endX, endY) = face_box
        face_center_x = (startX + endX) // 2
        face_center_y = (startY + endY) // 2
        if flip_x:
            face_center_x = 320 - face_center_x
        if flip_y:
            face_center_y = 240 - face_center_y
        dx = face_center_x - 160
        dy = face_center_y - 120
        if abs(dx) > dead_zone:
            target_x = clamp(target_x + dx * 0.05, servo_min, servo_max)
        if abs(dy) > dead_zone:
            target_y = clamp(target_y + dy * 0.05, servo_min, servo_max)
        cv2.rectangle(frame, (startX, startY), (endX, endY), (0, 255, 0), 2)

    elif time.time() - last_seen_time > face_stable_timeout:
        if time.time() > idle_hold_until:
            jitter_x = random.randint(-idle_amplitude_x, idle_amplitude_x)
            jitter_y = random.randint(-idle_amplitude_y, idle_amplitude_y)
            idle_target = (
                clamp(idle_center_x + jitter_x, servo_min, servo_max),
                clamp(idle_center_y + jitter_y, servo_min, servo_max)
            )
            idle_hold_until = time.time() + random.uniform(3.0, 6.0)
        if time.time() > idle_hold_until - 4.5:
            target_x, target_y = idle_target

    if time.time() - last_mood_time > mood_interval:
        update_feeling_brain(frame)
        last_mood_time = time.time()

    current_mood = get_current_mood()

    # === SERVO EASING ===
    servo_x = servo_x * (1 - easing_factor) + target_x * easing_factor
    servo_y = servo_y * (1 - easing_factor) + target_y * easing_factor

    # === BREATHING LOGIC ===
    mood_clamped = max(0.0, min(1.0, (current_mood + 1.0) / 2.0))
    face_bonus = 1.2 if person_present else 0.0
    target_breath_speed = 6.0 - (mood_clamped * 5.5) - face_bonus
    breath_speed = breath_speed * 0.95 + target_breath_speed * 0.05
    angular_speed = 2 * math.pi / breath_speed

    breath_phase = math.sin(lung_angle)
    if not breath_paused:
        if breath_phase > 0.98 and last_breath_direction != 'up':
            breath_paused = True
            pause_start_time = time.time()
            last_breath_direction = 'up'
        elif breath_phase < -0.98 and last_breath_direction != 'down':
            breath_paused = True
            pause_start_time = time.time()
            last_breath_direction = 'down'
        else:
            lung_angle += angular_speed * delta
    else:
        if time.time() - pause_start_time > pause_duration:
            breath_paused = False

    offset = -0.15 * current_mood
    raw_lung = (math.sin(lung_angle + offset) + 1) / 2
    lung_pos = int(raw_lung * (lung_max - lung_min) + lung_min)

    # === SERIAL OUTPUT ===
    message = f"{int(servo_x)},{int(servo_y)},{lung_pos}\n"
    ser.write(message.encode())

    # === PREVIEW ===
    cv2.imshow("Camera", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
